<a name="database" class="anchor"></a>
<h1>
  Database
</h1>

<p>
  Now it might be that the database setup in this project isn't the simplest possible. However, I've set it up in a way,
  such that it has the highest flexibility possible. Not everyone is happy with MongoDB and the way it's set up here,
  it shouldn't be too much of a hassle to switch to another database. At least from a source code perspective, migrating
  production data will of course still be painful.
</p>
<p>
  Since it's a MongoDB, we'll first install the related npm packages and types
</p>
<pre class="code-snippet">
npm install --save mongodb
npm install --save-dev @types/mongodb
</pre>

<h3>
  Connecting to the database
</h3>
<p>
  Afterwards, we'll have to connect to the db. That is what this class is for.
</p>


<amp-accordion>
  <section>
    <h5 class="file-label-two">backend/src/db/database.ts</h5>
    <pre class="code-snippet">{{> ./sections/database/database.ts.html}}</pre>
  </section>
  <section>
    <h5 class="file-label-two">backend/src/db/database.test.ts</h5>
    <pre class="code-snippet">{{> ./sections/database/database.test.ts.html}}</pre>
  </section>
</amp-accordion>

<p>
  As you may have noticed, the tests import a <code>before-eachs</code> module we haven't created so far. So lets go ahead
  and create it
</p>
<div class="file-label">backend/src/test/before-eachs.ts.html</div>
<pre class="code-snippet">{{> ./sections/database/before-eachs.ts.html}}</pre>
<p>
  This allows us to always connect to the database in the tests with a single line of code and callback free.
</p>

<p>
  Again, run <code>npm test</code> to check if everything is running smoothly so far.
</p>


<h3>
  Inserting, Reading, Updating & Deleting Data
</h3>
<p>
  Now that we can connect to our database, we can also start writing the actual database layer that inserts and extracts
  data to- and from the database. We will call this layer the "Database Access Object" or short "dao". Hence, the following files
</p>

<amp-accordion>
  <section>
    <h5 class="file-label-two">backend/src/db/dao.ts</h5>
    <pre class="code-snippet">{{> ./sections/database/dao.ts.html}}</pre>
  </section>
  <section>
    <h5 class="file-label-two">backend/src/db/dao.test.ts</h5>
    <pre class="code-snippet">{{> ./sections/database/dao.test.ts.html}}</pre>
  </section>
  <section>
    <h5 class="file-label-two">backend/src/db/database-response.model.ts</h5>
    <pre class="code-snippet">{{> ./sections/database/database-response.model.ts.html}}</pre>
  </section>
  
</amp-accordion>

<p>
  In order to make this work, we also have to create a <code>src/utils/utils</code> file that looks like so
</p>
<div class="file-label">backend/src/utils/utils.ts</div>
<pre class="code-snippet">{{> ./sections/database/utils.ts.html}}</pre>

<p>
  It's quite a lot of code, but don't get intimidated, it's actually not that complex. What you have to know to understand it
  is the following:
</p>
<ul>
  <li>
    It implements basic database-access methods, such as create, read, update and delete (CRUD, maybe you've heard of it).
  </li>
  <li>
    It abstracts away the mongo-ness. Everything that will use the <code>dao</code> will <strong>not know</strong>
    that a MongoDB was used. That way, in case you want to switch out Mongo, it's fairly easy.
  </li>
  <li>
    Since the field <code>_id</code> smells like Mongo, it's morphed into another field called <code>uid</code>.
  </li>
  <li>
    The MongoDB-Response is also wrapped in a application db-response.
  </li>
</ul>
<p>
  I know this bloats the code a bit, but it safeguards you against getting locked into something you don't want to.
  Again you can test if everything's running so far with <code>npm test</code>.
</p>
