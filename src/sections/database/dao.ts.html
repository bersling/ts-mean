         data: this.morphDataOnRetrieval(itemCopy)
            });
          }
        });
      }
    });
  }


  delete(id: string, collectionName: string, cb: (dbResp: DatabaseResponse) => void): void {
    database.database.collection(collectionName, (err, collection) => {
      if (err) {
        cb({
          error: this.mongoErrorToGeneralDbError(err)
        });
      } else {
        collection.deleteOne({'_id': new mongo.ObjectID(id)}, (innerError, result) => {
          if (innerError) {
            cb({
              error: this.mongoErrorToGeneralDbError(innerError)
            });
          } else {
            cb({
              error: null
            });
          }
        });
      }
    });
  }


  private mongoErrorToGeneralDbError (err: MongoError): DatabaseError {
    return {
      code: err.code,
      message: err.message
    };
  }

  private morphDataOnRetrieval(data, logme?: boolean) {

    if (!data) {
      log.error('No data!');
      return;
    }

    const dataCopy = utils.deepCopyData(data);

    const morphResource = (resource): void => {
      if (typeof resource._id !== 'string') {
        resource.uid = resource._id.toHexString();
      } else {
        resource.uid = resource._id;
      }
      delete resource._id;
    };

    if (Array.isArray(dataCopy)) {
      dataCopy.forEach(resource => {
        morphResource(resource);
      });
    } else {
      morphResource(dataCopy);
    }

    return dataCopy;
  };

  private morphDataOnStorage(data) {
    const dataCopy = utils.deepCopyData(data);
    dataCopy._id = data.uid;
    delete dataCopy.uid;
    return dataCopy;
  };

}

export const dao = new DAO();
One(itemCopy, (innerError: MongoError, result) => {
          if (innerError) {
            cb({
              error: this.mongoErrorToGeneralDbError(innerError)
            });
          } else {
            cb({
              error: null,
              data: this.morphDataOnRetrieval(itemCopy)
            });
          }
        });
      }
    });
  }


  update(item, collectionName: string, cb: (dbResp: DatabaseResponse) => void): void {

    // deep copy object so input doesn't get mutated and morph it to correct storage form
    const itemCopy = this.morphDataOnStorage(item);

    database.database.collection(collectionName, (err, collection) => {
      if (err) {
        cb({
          error: this.mongoErrorToGeneralDbError(err)
        });
      } else {
        collection.updateOne({'_id': new mongo.ObjectID(itemCopy._id)}, item, (innerError: MongoError, result) => {
          if (innerError) {
            cb({
              error: this.mongoErrorToGeneralDbError(innerError)
            });
          } else {
            cb({
              error: null,
     