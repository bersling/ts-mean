<a name="authentication" class="anchor"></a>
<h1>
  Authentication
</h1>
<p>
  We have already achieved a lot. We've set up and configured an application that can read & write to MongoDB
  and which can be talked to over a RESTful API. However, usually we don't allow anybody everything.
  So in this last step for the backend, we're going to add authentication.
</p>
<p>
  Since we never ever store plain text passwords in our database, as a first and independent step we can start
  to set up a password encryption algorithm. A good choice for an encryption algorithm for passwords is <code>bcrypt</code>.
  Luckily there's a npm module implementing this algorithm, so we just have to wire things together. Let's first install
  the npm module.
</p>
<pre class="code-snippet">
npm install --save bcrypt
npm install --save-dev @types/bcrypt
</pre>
<p>
  For some of you this installation might throw a few warnings with <code>node-gyp</code>,
  but overall it should still work and install correctly. To test this, we have the following two files.
</p>

<div class="file-label">src/auth/password-cryptograher.ts</div>
<pre class="code-snippet">{{> ./sections/authentication/password-cryptographer.ts.html}}</pre>

<div class="file-label">src/auth/password-cryptograher.test.ts</div>
<pre class="code-snippet">{{> ./sections/authentication/password-cryptographer.test.ts.html}}</pre>

<p>
  We're starting to be at an application size where it's annoying to always have to run all unit tests.
  In the <code>package.json</code> we've already set a method to run a single test. So in order to check if bcrypt is
  working, run <code>TEST=bcrypt npm run spec</code>. Like this, every <code>describe</code> or <code>it</code> containing
  the sequence "bcrypt" is run.
</p>
<p>
  What we now can do building on the password cryptographer is creating users and storing their passwords as hashed values.
  In the <code>db</code> directory, create the <code>UserDAO</code> and its corresponding test and model.
</p>

<div class="file-label">src/db/user-dao.ts</div>
<pre class="code-snippet">{{> ./sections/authentication/user-dao.ts.html}}</pre>

<div class="file-label">src/db/user-dao.test.ts</div>
<pre class="code-snippet">{{> ./sections/authentication/user-dao.test.ts.html}}</pre>

<div class="file-label">src/db/user.model.ts</div>
<pre class="code-snippet">{{> ./sections/authentication/user.model.ts.html}}</pre>

<p>
  So the UserDAO can create a new user if and only if no user with this e-mail already exists. This test can be ran
  with <code>TEST=user npm run spec</code>. You might also ask, why the "hashing-algorithm" is stored on the user.
  This isn't strictly necessary, but in case you're running in production and want to switch the hashing algorithm,
  you could upload the new algorithm and run the two algorithms parallel while you have time to migrate the old
  hashed values.
</p>
<p>
  Last but not least we want to be able to authenticate the user, meaning that when he or she tries to log in
  providing username / email and password we can return success or fail. This is done with yet another npm module,
  namely <code>passport</code>. To install it, run
</p>

<pre class="code-snippet">
npm install --save passport passport-local
npm install --save-dev @types/passport @types/passport-local
</pre>

<p>
  What is <code>passport</code> good for? In short, you can add different authentication methods to endpoints easily.
  It also has a lot of different pre-implemented methods, "strategies" as they call them, for example for Google+ or Facebook
  authentication. We'll start with a "local strategy" meaning an authentication specific to the application.
  So let's set up this local strategy.
</p>

<div class="file-label">src/auth/passport.ts</div>
<pre class="code-snippet">{{> ./sections/authentication/passport.ts.html}}</pre>

<div class="file-label">src/auth/passport.test.ts</div>
<pre class="code-snippet">{{> ./sections/authentication/passport.test.ts.html}}</pre>

<p>
  As you can see we're leveraging the password-encryption previously wired up to check if the provided plaintext password
  matches the hash. Once this strategy is set up, we can use it in our endpoints. Here, we're going to implement a
  <code>Login</code> endpoint. It looks like this
</p>


<amp-accordion>
  <section>
    <div class="file-label-two">src/router/endpoints/login-router.ts</div>
    <pre class="code-snippet">{{> ./sections/authentication/login-router.ts.html}}</pre>
  </section>
  <section>
    <div class="file-label-two">src/router/endpoints/login-router.test.ts</div>
    <pre class="code-snippet">{{> ./sections/authentication/login-router.test.ts.html}}</pre>
  </section>
</amp-accordion>


<p>
  If you were to run <code>TEST=login npm run spec</code> now it would still fail. Why? We yet have to register this new
  route in the router. So open <code>router.ts</code> and add the following line
</p>

<pre class="code-snippet">
this.express.use('/api/v1/', loginRouter);
</pre>

<p>
  <strong>above</strong> the <code>simpleCrudRouter</code>. You'll have to add it above, since the simpleCrudRouter
  already occupies the endpoint <code>/api/v1/login</code>, but express tries to match from top to bottom. Also, don't
  forget the import at the top
</p>

<pre class="code-snippet">
import {loginRouter} from "./endpoints/login-router";
</pre>

<p>
  Wow okay, that's it, we're pretty much at the end of our backend journey. You should be able to run <code>npm test</code>
  and have all running tests. Furthermore you should be able to start the server with <code>npm start</code>, so you
  have a running backend which you can implement the frontend against. Which is what we're going to do next.
</p>


