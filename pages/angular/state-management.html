<!doctype html>
<html ⚡ lang="en">
<head>
  
  {{> ./components/common-head.html}}
  <title>State Management in Angular2+</title>
  <meta name="description" content="State management is probably the biggest challenge for complex frontend projects. Unfortunately, the Angular Documentation offers very little guidance on this. Here's your missing guide!">
  <meta name="keywords"
        content="Angular, Angular2, Angular4, Tutorial, how-to, State Management">
  <link rel="canonical" href="http://www.tsmean.com/angular/state-management" />

</head>
<body class="landing">
  
  {{> ./components/analytics.html}}
  
  <a name="top" class="anchor"></a>
  
  {{> ./components/header.html}}
  
  <div class="jumbotron">
    <p class="jumbo-slogan">
      State Management in Angular2+
    </p>
    <amp-img src="/img/angular/state-management/manage-state.svg"
             class="jumbo-logo xs-hide"
             alt="TypeScript Mean Banner"
             width="250"
             height="250">
    </amp-img>
  </div>
  
  <article class="flex-auto">
    
    <p>
      When we’re talking about state in this article, what we mean is what values the variables in your systems have. Let’s say your webapp is a simple list of items, where each item has a title. Then a change of state would be if you’d create a new item, update an item or remove an item. If your webapp permits it, also if you reorder the items.
    </p>
  
    <p>
      Now the question is, how do we keep track of changes in the state, such that all parts of our app are synchronized and the changes are reflected in the view? This is what this tutorial is about. Basically there are two approaches for where to store state:
    </p>
  
    <ol>
      <li>
        You can store it in a service
      </li>
      <li>
        You can store it in a component
      </li>
    </ol>
    
    <p>
      The tricky part is to know when to use which option, as this isn't always obvious. State management an opinionated topic, so what you're about to read is <i>my</i> view on it.
    </p>
  
    <h2>
      Using services to manage state
    </h2>
    <p>
      Angular services are singletons, which makes them ideal to store data. You can be sure, that when you fetch data from a service, you’ll get the same data across the app. Now the question is, how should we store data in services, such that it is automatically updated across the entire application? The answer are observables. The concrete implementation looks a bit differently for different data types we want to store. For example, if we have an object with an id, we would store it differently from when we would store id-less data. Here's how we'd go about each of those cases.
    </p>
    
    <h3>
      Storing data with an id
    </h3>
    <p>
      To continue with the previous example, let’s say we fetch the items from our database and they come with an id. Then we can simply build a item-store like this:
    </p>
  
    <span class="file-label">item.store.ts</span>
    <pre class="code-snippet">
      items: {[itemId: string]: item} = {}
      -- copy resource store --
    </pre>
    
    <p>
      What we’re doing is we’re not adding the resources directly, but instead we’re adding an observable. In case you’ve never heard of observables, you first need to familiarize yourself with the concept in order to understand this. Here's a tutorial on observables:
      <a href="https://www.youtube.com/watch?v=Tux1nhBPl_w">https://www.youtube.com/watch?v=Tux1nhBPl_w</a>. The observables enable us to subscribe to changes in the data, such that the application is always synchronized everywhere:
    </p>
  
    <amp-img src="/img/angular/state-management/update-all.png"
             class="mwc-450"
             alt="update all"
             layout="responsive"
             width="624" height="582">
    </amp-img>
  
    <h3>
      Storing id-less data in a service
    </h3>
    <p>
      Not only do services lend themselves well for objects with an id, but they are also well suited for id less data, like our item-list. There, the state consists of which items are in the list in which order. So adding or removing an item as well as reordering the list would change the state of the item-list. Our item-list store could look like this:
    </p>
    
    <span class="file-label">
      item-list.store.ts
    </span>
<pre class="code-snippet">
import {Injectable} from '@angular/core';
import {Observable} from 'rxjs/Observable';
import {BehaviorSubject} from 'rxjs/BehaviorSubject';

@Injectable()
export class AnimalDashboardListStore {

  private dashboardList = new BehaviorSubject([]);

  constructor() { }

  /**
   * Adds a resourceId to the list. If no position is provided, appends it to the end.
   */
  add (resourceId: string, index?: number): void {
    const currentValue = this.dashboardList.getValue(); // todo: check immutability
    if (index !== undefined) {
      if (index <= currentValue.length) {
        currentValue.splice(index, 0, resourceId);
        this.dashboardList.next(currentValue);
      } else {
        throw new Error('Index of bounds. Cannot add animal.');
      }
    } else {
      currentValue.push(resourceId);
      this.dashboardList.next(currentValue);
    }
  }

  /**
   * Resets the entire list
   */
  set(newList: string[]): void {
    this.dashboardList.next(newList);
  }

  /**
   * Remove a single item from the list by its id
   */
  removeById (resourceId: string): void {
    const currentValue = this.dashboardList.getValue();
    this.dashboardList.next(currentValue.filter(id => id !== resourceId));
  }


  /**
   * Remove a single item from the list by its position
   */
  removeByIndex (index: number): void {
    const currentValue = this.dashboardList.getValue();
    currentValue.splice(index, 1);
    this.dashboardList.next(currentValue);
  }


  /**
   * Get the list-observable
   */
  get(): Observable<string[]> {
    return this.dashboardList;
  }


  /**
   * Update an item in the list by its index
   */
  updateByIndex (index: number, newResourceId: string): void {
    const currentValue = this.dashboardList.getValue();
    if (index <= currentValue.length) {
      currentValue[index] = newResourceId;
      this.dashboardList.next(currentValue);
    } else {
      throw new Error('Index of bounds. Cannot update animal.');
    }
  }

  /**
   * Update an item in the list by its id
   */
  updateById (id: string, newResourceId: string): void {
    const currentValue = this.dashboardList.getValue();
    const newValue = currentValue.map(x => x === id ? newResourceId : x);
    this.dashboardList.next(newValue);
  }

}
</pre>
    
    <p>
      So we don’t have an id, but none the less, the objects from the item list can be updated through the service. In all subscribed components, the data our update logic is then triggered when a change in the item-list store happens. Angular then takes care of changing the view. That's the advantage of Angular over, for example, JQuery: You only need to update the controller data and Angular will then do the binding to the view.
    </p>
  
    <h2>
      Storing state in the component
    </h2>
    <p>
      For very simple cases you can also store state in the component itself. For example, if you were to use a <spacer height=”20”></spacer> component, that just inserts a div of a certain height in pixels. There state is so localized, that it’s completely sufficient to just store the state on the component of the spacer:
    </p>
  
    -- show spacer code --
  
    <p>
      As a rule of thumb, in case you think you will need to change the state in a different component than where it is displayed, you’re probably better off using a service as the data store. If you’re using and changing the state only in one component, it is fine to just store it in the components itself.
    </p>
    
    <p>
      To be precise, we were also storing state in the components when using services as stores. However, the updates always go through the service. That's what's different.
    </p>
  
    <h2>
      Conclusion
    </h2>
  
    <p>
      State management is a tricky business and you need to be proficient in all methods to write maintainable and scalable applications. Here’s a quick summarization of how I would recommend to handle states:
    </p>
  
    -- flowchart --
  
    Does your object have an id? -> resource store
  
    Your item doesn’t have an id (e.g. is a list), but can be changed through other components (e.g. a create button or delete button) -> store specific to this item
  
    You have some state that is 100% localized to a component and is only changed by the component itself? -> store & change state on component
  
    
  </article>
  
  {{> ./components/social-footer.html}}
  
  {{> ./components/footer.html}}

</body>
</html>
